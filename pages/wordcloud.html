---
# File: pages/wordcloud.html
# Purpose: Unified word cloud view. Lets users pick a faculty/centre first, then optionally a degree/programme.
# How to use:
#   - Choose a faculty/centre.
#   - Choose "Tots" (default) to see the faculty/centre word cloud, or pick an "Ensenyament" to see the programme word cloud.
# Related files:
#   - assets/js/site.js (sidebar UX / mobile)
#   - assets/css/styles.css (layout + active link styles)
#   - https://geourv.github.io/urv-sdgs-api/versions.json
#   - https://geourv.github.io/urv-sdgs-api/v1/index/*.json
#   - https://geourv.github.io/urv-sdgs-api/v1/centres_programs_detail/*.json
#   - https://geourv.github.io/urv-sdgs-api/v1/programmes-courses-detail/*.json
# Safe edits:
#   - OK: change labels, reorder controls, adjust default faculty.
#   - Careful: keep element ids used by the inline JS (#facultySelect, #degreeSelect, #wordcloud).
layout: default
title: "Núvol de paraules"
head_scripts:
  - https://cdn.jsdelivr.net/npm/wordcloud@1.1.1/src/wordcloud2.min.js
---

  <header class="w3-container" style="padding-top:10px">
    <h5><b><i class="fa fa-eye"></i> Una primera ullada &gt; Núvol de paraules</b></h5>
  </header>

  <div class="w3-container">
    <div class="wordcloud-title-row">
      <h1>Núvol de paraules</h1>
      <button
        id="wordcloudIntroToggle"
        type="button"
        class="w3-button w3-small w3-round w3-border wordcloud-info-toggle"
        aria-controls="wordcloudIntroPanel"
        aria-expanded="false"
        aria-label="Mostra o oculta la descripció de la visualització"
        title="Mostra o oculta la descripció de la visualització">
        <i class="fa fa-plus wordcloud-info-toggle-icon" aria-hidden="true"></i>
        <span class="wordcloud-sr-only">Info</span>
      </button>
    </div>

    <div id="wordcloudIntroPanel" class="wordcloud-intro-panel" hidden>
      <p>Aquesta visualització mostra un núvol de paraules amb els termes
        relacionats amb els Objectius de Desenvolupament Sostenible (ODS)
        associats a cada Facultat i Escola de la Universitat Rovira i Virgili.
        Permet filtrar per sistema de classificació i per secció analitzada
        (competències, informació de l’assignatura, referències, unions i interseccions).</p>
      <p>Els termes son dels conceptes detectats per un algoritme d'aprenentatge automàtic però,
        no necessàriament apareixen explicitats a les guies docents.</p>
    </div>
  </div>
<!-- interactive section -->
<div class="w3-container">
  <div class="interactive-chart-container wordcloud-layout">
    <div class="wordcloud-left-stack">
      <div class="wordcloud-primary-card">
        <div class="wordcloud-card-title">Selecció de facultat i ensenyament</div>

        <div class="wordcloud-primary-item wordcloud-primary-item--faculty">
          <div class="selector-container">
            <div class="selector-box">
              <select id="facultySelect" class="w3-select w3-border" aria-label="Facultat o Escola">
                <option value="">Facultat/Escola (obligatori)</option>
              </select>
            </div>
          </div>
        </div>

        <div class="wordcloud-primary-item wordcloud-primary-item--degree">
          <div class="selector-container">
            <div class="selector-box">
              <select id="degreeSelect" class="w3-select w3-border" aria-label="Ensenyament opcional">
                <option value="" selected disabled>Ensenyament (opcional): selecciona o tria "Tots"</option>
                <option value="ALL">Tots</option>
              </select>
            </div>
          </div>
        </div>
      </div>

      <div class="wordcloud-config-col">
        <div class="wordcloud-config-title wordcloud-card-title">Anàlisi del núvol</div>

        <label class="wordcloud-field-label" for="systemSelect">Sistema de classificació</label>
        <div class="selector-container">
          <div class="selector-box">
            <select id="systemSelect" class="w3-select w3-border">
              <option value="">Carregant sistemes...</option>
            </select>
          </div>
        </div>

        <label class="wordcloud-field-label" for="sectionSelect">Secció analitzada</label>
        <div class="selector-container">
          <div class="selector-box">
            <select id="sectionSelect" class="w3-select w3-border">
              <option value="">Carregant seccions...</option>
            </select>
          </div>
        </div>

        <label class="wordcloud-field-label" for="wordLimitRange">Nombre màxim de termes: <span id="wordLimitValue">70</span></label>
        <div class="selector-container">
          <input
            id="wordLimitRange"
            type="range"
            min="20"
            max="95"
            step="5"
            value="70"
            style="width: 100%;"
            aria-label="Nombre màxim de termes al núvol">
        </div>

        <div class="selector-container wordcloud-action-row">
          <button
            id="recolorBtn"
            type="button"
            class="w3-button w3-border w3-round"
            title="Prova una nova paleta de colors per al núvol actual"
            disabled>
            <i class="fa fa-paint-brush" aria-hidden="true"></i> Recolora el núvol
          </button>
        </div>

        <p id="apiInfo" class="w3-small w3-text-grey" style="margin-top: 0.9rem;"></p>
        <p id="wordcloudStatus" class="w3-small w3-text-grey" style="margin-top: 0.25rem;"></p>
      </div>

      <button
        id="mobileCloudHint"
        type="button"
        class="mobile-cloud-hint"
        aria-label="Baixa per veure el núvol de paraules"
        hidden>
        <span>Baixa per veure el núvol</span>
        <i class="fa fa-chevron-down" aria-hidden="true"></i>
      </button>
    </div>

    <aside id="selectionPanel" class="wordcloud-selection-panel" aria-live="polite">
      <h3 id="selectionPanelTitle" class="wordcloud-selection-title wordcloud-card-title"></h3>
      <p id="selectionPanelScope" class="wordcloud-selection-text"></p>
      <p id="selectionPanelCourses" class="wordcloud-selection-text"></p>
      <p id="selectionPanelSystem" class="wordcloud-selection-text"></p>
      <p id="selectionPanelSection" class="wordcloud-selection-text"></p>
      <p id="selectionPanelLimit" class="wordcloud-selection-text"></p>
      <p id="selectionPanelPalette" class="wordcloud-selection-text"></p>
    </aside>

    <div class="wordcloud-wrapper">
      <canvas id="wordcloud"></canvas>
    </div>
  </div>
</div>

<style>
/* Page-specific layout for wordcloud controls */
.wordcloud-layout {
  display: grid;
  grid-template-columns: minmax(250px, 320px) minmax(0, 1fr) minmax(0, 1fr) minmax(280px, 350px);
  grid-template-areas: "left cloud cloud panel";
  align-items: start;
  gap: 12px 14px;
  --wc-blue: var(--site-accent, #5f7898);
  --wc-blue-dark: var(--site-accent-dark, #4e6582);
  --wc-card-bg: var(--site-surface-2, #e8eff7);
  --wc-card-border: #cfdae6;
  --wc-card-title: #1f2a36;
  --wc-select-bg: #fff;
  --wc-select-border: #c4d0dc;
  --wc-postit-bg: #edf3fa;
  --wc-postit-border: #cfdae6;
  --wc-postit-text: #243242;
}

.wordcloud-title-row {
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}

.wordcloud-title-row h1 {
  margin: 0;
}

.wordcloud-info-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 42px;
  height: 42px;
  min-width: 42px;
  padding: 0;
  border-radius: 999px !important;
  border-color: var(--site-accent-dark, #334457) !important;
  color: #fff !important;
  background: var(--site-accent, #3f536b);
  font-weight: 600;
}

.wordcloud-info-toggle:hover,
.wordcloud-info-toggle:focus {
  background: var(--site-accent-dark, #334457) !important;
  border-color: var(--site-accent-dark, #334457) !important;
  color: #fff !important;
}

.wordcloud-info-toggle-icon {
  font-size: 1.4em;
  line-height: 1;
  transition: transform 0.2s ease;
}

.wordcloud-info-toggle[aria-expanded="true"] {
  background: #fff !important;
  color: var(--site-accent-dark, #334457) !important;
  border-color: var(--site-accent, #3f536b) !important;
}

.wordcloud-info-toggle[aria-expanded="true"]:hover,
.wordcloud-info-toggle[aria-expanded="true"]:focus {
  background: #edf3fa !important;
  color: var(--site-accent-dark, #334457) !important;
  border-color: var(--site-accent-dark, #334457) !important;
}

.wordcloud-info-toggle[aria-expanded="true"] .wordcloud-info-toggle-icon {
  transform: rotate(45deg);
}

.wordcloud-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  border: 0;
}

.wordcloud-intro-panel {
  margin-top: 0.55rem;
  padding: 10px 12px;
  border: 1px solid var(--wc-postit-border);
  border-radius: 8px;
  background: var(--wc-postit-bg);
}

.wordcloud-intro-panel p {
  margin: 0 0 0.55rem;
}

.wordcloud-intro-panel p:last-child {
  margin-bottom: 0;
}

.mobile-cloud-hint {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  width: 100%;
  margin: 2px 0 0;
  padding: 9px 10px;
  border: 1px dashed #a9bbce;
  border-radius: 8px;
  background: #f3f7fc;
  color: #2f4c69;
  font-size: 0.9rem;
  font-weight: 700;
  cursor: pointer;
}

.mobile-cloud-hint:hover,
.mobile-cloud-hint:focus {
  background: #e9f1fa;
  border-color: #8ea4bc;
  color: #253d54;
}

.mobile-cloud-hint i {
  animation: mobile-cloud-hint-bounce 1.2s ease-in-out infinite;
}

@keyframes mobile-cloud-hint-bounce {
  0%, 100% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(4px);
  }
}

.wordcloud-left-stack {
  grid-area: left;
  min-width: 0;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.wordcloud-primary-card,
.wordcloud-config-col {
  background: var(--wc-card-bg);
  border: 1px solid var(--wc-card-border);
  border-radius: 10px;
  box-shadow: 0 1px 3px rgba(33, 52, 75, 0.1);
}

.wordcloud-primary-card,
.wordcloud-config-col {
  padding: 14px 14px 12px;
}

.wordcloud-config-col {
  color: var(--wc-card-title);
}

.wordcloud-card-title {
  margin: 0 0 10px;
  font-weight: 800;
  font-size: 1.06rem;
  letter-spacing: 0.01em;
  color: var(--wc-card-title);
  line-height: 1.3;
  padding-bottom: 8px;
  border-bottom: 1px solid #d3deea;
}

.wordcloud-primary-item {
  background: transparent;
  border: 0;
  border-radius: 0;
  padding: 0;
  box-shadow: none;
}

.wordcloud-primary-item + .wordcloud-primary-item {
  margin-top: 0.55rem;
}

.wordcloud-primary-item .selector-container,
.wordcloud-config-col .selector-container {
  margin-bottom: 0;
  gap: 8px;
}

.wordcloud-layout .selector-box {
  margin-bottom: 0;
}

.wordcloud-primary-item strong,
.wordcloud-config-col strong {
  color: var(--wc-card-title);
}

.wordcloud-field-label {
  display: block;
  margin: 0.52rem 0 0.24rem;
  font-weight: 700;
  font-size: 0.9rem;
  line-height: 1.25;
  color: var(--wc-card-title);
}

.wordcloud-config-col .wordcloud-field-label:first-of-type {
  margin-top: 0.35rem;
}

.wordcloud-wrapper {
  grid-area: cloud;
  min-width: 0;
  overflow: hidden;
  border: 0;
  border-radius: 0;
  background: transparent;
  box-shadow: none;
}

.wordcloud-selection-panel {
  grid-area: panel;
  position: relative;
  background: var(--wc-postit-bg);
  border: 1px solid var(--wc-postit-border);
  border-radius: 10px;
  box-shadow: 0 2px 8px rgba(33, 52, 75, 0.1);
  padding: 12px 13px;
  color: var(--wc-postit-text);
}

.wordcloud-selection-title {
  margin: 0 0 10px;
  color: #1f2a36;
  border-bottom: 1px solid rgba(95, 120, 152, 0.35);
}

.wordcloud-selection-text {
  margin: 0 0 8px;
  font-size: 1rem;
  color: var(--wc-postit-text);
  line-height: 1.4;
}

.wordcloud-selection-text:last-child {
  margin-bottom: 0;
}

.wordcloud-selection-text strong {
  color: #2f4c69;
  font-weight: 900;
  text-decoration: none;
  background: rgba(95, 120, 152, 0.14);
  display: inline-block;
  border-radius: 6px;
  border-bottom: 2px solid rgba(95, 120, 152, 0.46);
  padding: 0.08em 0.34em;
}

.wordcloud-action-row {
  justify-content: center;
  margin-top: 0.55rem;
}

#recolorBtn {
  background-color: var(--wc-blue);
  color: #fff;
  border-color: var(--wc-blue-dark) !important;
  font-weight: 700;
  border-radius: 6px !important;
}

#recolorBtn:hover:not(:disabled),
#recolorBtn:focus:not(:disabled) {
  background-color: var(--wc-blue-dark);
  color: #fff;
}

#recolorBtn:disabled {
  background-color: #dfe5ed;
  color: #79889b;
  border-color: #c8d2de !important;
}

#wordcloud {
  display: block;
  width: 100%;
  height: 100%;
}

.wordcloud-layout .w3-select {
  width: 100%;
  min-width: 0;
  background-color: var(--wc-select-bg);
  color: #111;
  border: 1px solid var(--wc-select-border) !important;
  border-radius: 6px;
  padding: 10px 36px 10px 12px;
  min-height: 42px;
  line-height: 1.2;
  box-sizing: border-box;
}

.wordcloud-layout .w3-select:focus {
  background-color: #f7fbff;
  border-color: var(--wc-blue) !important;
  box-shadow: 0 0 0 2px rgba(95, 120, 152, 0.22);
}

.wordcloud-layout .w3-select:disabled {
  background-color: #eef2f7;
  color: #7b8a9d;
}

#wordLimitRange {
  accent-color: var(--wc-blue);
}

#wordLimitRange:disabled {
  accent-color: #a9b7c8;
}

#apiInfo,
#wordcloudStatus {
  color: #5f6e7f !important;
}

.wordcloud-source-link {
  color: #45637f !important;
  font-weight: 600;
  text-decoration: underline;
}

.wordcloud-source-link:visited {
  color: #45637f !important;
}

.wordcloud-source-link:hover,
.wordcloud-source-link:focus {
  color: var(--wc-blue-dark) !important;
}

@media (max-width: 1250px) {
  .wordcloud-layout {
    grid-template-columns: minmax(240px, 300px) minmax(0, 1fr) minmax(260px, 330px);
    grid-template-areas: "left cloud panel";
  }
}

@media (max-width: 1000px) {
  .wordcloud-layout {
    grid-template-columns: 1fr;
    grid-template-areas:
      "left"
      "cloud"
      "panel";
  }
}

@media (min-width: 1001px) {
  .mobile-cloud-hint {
    display: none !important;
  }
}
</style>

<script>
// File: inline script in pages/wordcloud.html
// Purpose: Load wordcloud data from URV SDGs API with on-demand detail fetches and local cache.

const facultySelect = document.getElementById("facultySelect");
const degreeSelect = document.getElementById("degreeSelect");
const systemSelect = document.getElementById("systemSelect");
const sectionSelect = document.getElementById("sectionSelect");
const wordLimitRange = document.getElementById("wordLimitRange");
const wordLimitValue = document.getElementById("wordLimitValue");
const recolorBtn = document.getElementById("recolorBtn");
const statusEl = document.getElementById("wordcloudStatus");
const apiInfoEl = document.getElementById("apiInfo");
const selectionPanelTitleEl = document.getElementById("selectionPanelTitle");
const selectionPanelScopeEl = document.getElementById("selectionPanelScope");
const selectionPanelCoursesEl = document.getElementById("selectionPanelCourses");
const selectionPanelSystemEl = document.getElementById("selectionPanelSystem");
const selectionPanelSectionEl = document.getElementById("selectionPanelSection");
const selectionPanelLimitEl = document.getElementById("selectionPanelLimit");
const selectionPanelPaletteEl = document.getElementById("selectionPanelPalette");
const introToggleBtn = document.getElementById("wordcloudIntroToggle");
const introPanelEl = document.getElementById("wordcloudIntroPanel");
const mobileCloudHintEl = document.getElementById("mobileCloudHint");
const canvas = document.getElementById("wordcloud");

const DEFAULT_SYSTEM_ID = "sys:any";
const DEFAULT_SECTION_ID = "sec:any";
const DEFAULT_WORDS_TO_RENDER = 70;
const MIN_WORDS_TO_RENDER = 20;
const MAX_WORDS_TO_RENDER = 95;
const MIN_WORD_SIZE = 11;
const MAX_WORD_SIZE = 92;
const API_BASE_CANDIDATES = Array.from(new Set([
  "{{ site.sdgs_api_base_url | default: 'https://geourv.github.io/urv-sdgs-api' }}",
  "https://raw.githubusercontent.com/geourv/urv-sdgs-api/main"
].map(v => String(v || "").trim().replace(/\/+$/, "")).filter(Boolean)));
const WORDCLOUD_STRINGS_URL = "{{ '/data/i18n/wordcloud.' | append: site.lang | append: '.json' | relative_url }}";
const WORDCLOUD_STRINGS_FALLBACK_URL = "{{ '/data/i18n/wordcloud.ca.json' | relative_url }}";
const WORDCLOUD_PALETTES = [
  {
    label: "Viva",
    colors: ["#d90429", "#f72585", "#f77f00", "#ffba08", "#3a86ff", "#8338ec", "#118ab2"]
  },
  {
    label: "Mediterrània",
    colors: ["#005f73", "#0a9396", "#94d2bd", "#ee9b00", "#ca6702", "#bb3e03", "#9b2226"]
  },
  {
    label: "Bosc i Terra",
    colors: ["#283618", "#606c38", "#6a994e", "#a7c957", "#bc4749", "#7f5539", "#386641"]
  },
  {
    label: "Neó",
    colors: ["#00a6fb", "#00f5d4", "#70e000", "#ffea00", "#ff5400", "#ff0054", "#9b5de5"]
  },
  {
    label: "Urbana",
    colors: ["#1d3557", "#457b9d", "#2b2d42", "#8d99ae", "#ef233c", "#ff9f1c", "#5f0f40"]
  },
  {
    label: "Suau",
    colors: ["#6d597a", "#b56576", "#e56b6f", "#eaac8b", "#355070", "#b08968", "#7f5539"]
  },
  {
    label: "Contrast Fosc",
    colors: ["#0d1b2a", "#1b263b", "#415a77", "#577590", "#2a9d8f", "#e76f51", "#f4a261"]
  },
  {
    label: "Retro",
    colors: ["#2f3e46", "#52796f", "#84a98c", "#e9c46a", "#f4a261", "#e76f51", "#9a031e"]
  }
];
const DEFAULT_UI_STRINGS = {
  panel: {
    empty_title: "Explicació del núvol de paraules",
    empty_scope: "Selecciona una Facultat/Escola i, opcionalment, un ensenyament per veure el resum detallat.",
    error_title: "No s'ha pogut actualitzar el resum",
    error_scope: "Revisa la selecció i torna a provar."
  },
  templates: {
    title_centre: "Explicació del núvol de paraules de {centre}",
    title_programme: "Explicació del núvol de paraules del programa {programme}",
    narrative_intro_centre: "Has seleccionat {centre}. Aquesta selecció inclou {n_programmes} ensenyaments i {n_courses} cursos analitzats.",
    narrative_intro_programme: "Has seleccionat el programa {programme} de {centre}, amb {n_courses} cursos analitzats.",
    narrative_method: "Per construir el núvol s'ha aplicat el sistema {system_label} ({system_mode}). {system_help} {system_quality}",
    narrative_context: "Pel que fa a la guia docent, {section_help} (criteri: {section_label}). El núvol mostra fins a {word_limit} termes i ara utilitza la paleta {palette_label}.",
    narrative_provenance: "Les fonts de captura són {platforms}.",
    narrative_scraping_date: "Data de l'scraping: {scraping_date}.",
    narrative_scraping_date_unknown: "Data de l'scraping: desconeguda.",
    scope_centre: "Selecció activa: tots els ensenyaments de {centre}.",
    scope_programme: "Selecció activa: {programme} ({centre}).",
    courses_line: "Aquesta selecció correspon a {n_courses} cursos.",
    programmes_line: "El centre inclou {n_programmes} ensenyaments.",
    system_line: "Sistema de classificació: {system_label}. {system_help}",
    system_mode_line: "Perfil del sistema: {system_mode}.",
    system_quality_line: "Precisió i falsos positius: {system_quality}",
    section_line: "Secció analitzada: {section_label}. {section_help}",
    limit_line: "Límit actual del núvol: {word_limit} termes.",
    palette_line: "Paleta activa: {palette_label}.",
    provenance_line: "Fonts de captura del scraping: {platforms}."
  },
  system_labels: {
    "sys:any": "Qualsevol sistema (Unió)",
    "sys:all": "Tots els sistemes (Intersecció)",
    "sys:auckland": "Auckland",
    "sys:aurora": "Aurora",
    "sys:elsevier": "Elsevier",
    "ens:equal": "Ensemble equal",
    "ens:third": "Ensemble third",
    "ens:triple": "Ensemble triple",
    "sys:sdgo": "SDGO",
    "sys:sdsn": "SDSN",
    "sys:siris": "SIRIS"
  },
  section_labels: {
    "sec:any": "Totes les seccions (Unió)",
    "sec:all": "Coincidència de totes les seccions (Intersecció)",
    "sec:competences": "Competències",
    "sec:course_info": "Informació de l'assignatura",
    "sec:references": "Referències"
  },
  system_explanations: {
    "sys:any": "Es marca un ODS quan apareix en qualsevol dels sistemes disponibles.",
    "sys:all": "Només es marca un ODS quan coincideix en tots els sistemes.",
    "sys:auckland": "Es fan servir únicament les deteccions del sistema Auckland.",
    "sys:aurora": "Es fan servir únicament les deteccions del sistema Aurora.",
    "sys:elsevier": "Es fan servir únicament les deteccions del sistema Elsevier.",
    "sys:ensemble_equal": "Es combinen diversos sistemes amb pes equivalent.",
    "sys:ensemble_third": "Es combinen sistemes amb llindar d'un terç de coincidència.",
    "sys:ensemble_triple": "Es combinen sistemes exigint una coincidència triple.",
    "sys:sdgo": "Es fan servir únicament les deteccions del sistema SDGO.",
    "sys:sdsn": "Es fan servir únicament les deteccions del sistema SDSN.",
    "sys:siris": "Es fan servir únicament les deteccions del sistema SIRIS.",
    "default": "Aquesta opció determina com es combinen les deteccions dels sistemes."
  },
  system_modes: {
    "sys:any": "inclusiu",
    "sys:all": "restrictiu",
    "sys:ensemble_equal": "equilibrat",
    "sys:ensemble_third": "intermedi",
    "sys:ensemble_triple": "molt restrictiu",
    "sys:auckland": "monosistema (Auckland)",
    "sys:aurora": "monosistema (Aurora)",
    "sys:elsevier": "monosistema (Elsevier)",
    "sys:sdgo": "monosistema (SDGO)",
    "sys:sdsn": "monosistema (SDSN)",
    "sys:siris": "monosistema (SIRIS)",
    "default": "configuració específica del sistema seleccionat"
  },
  system_quality_notes: {
    "sys:any": "Això incrementa la cobertura, però també pot augmentar els falsos positius.",
    "sys:all": "Això redueix els falsos positius, però pot deixar fora alguns casos límit.",
    "sys:ensemble_equal": "Acostuma a mantenir un bon equilibri entre cobertura i precisió.",
    "sys:ensemble_third": "Acostuma a ajustar millor els falsos positius que els modes més sensibles.",
    "sys:ensemble_triple": "Prioritza la precisió i minimitza al màxim els falsos positius.",
    "sys:auckland": "En aquest mode, la sensibilitat als falsos positius depèn del comportament d'aquest sistema.",
    "sys:aurora": "En aquest mode, la sensibilitat als falsos positius depèn del comportament d'aquest sistema.",
    "sys:elsevier": "En aquest mode, la sensibilitat als falsos positius depèn del comportament d'aquest sistema.",
    "sys:sdgo": "En aquest mode, la sensibilitat als falsos positius depèn del comportament d'aquest sistema.",
    "sys:sdsn": "En aquest mode, la sensibilitat als falsos positius depèn del comportament d'aquest sistema.",
    "sys:siris": "En aquest mode, la sensibilitat als falsos positius depèn del comportament d'aquest sistema.",
    "default": "Si vols menys falsos positius, prova una configuració més restrictiva."
  },
  section_explanations: {
    "sec:any": "es combinen totes les seccions de la guia docent.",
    "sec:all": "només es conserven termes que apareixen a totes les seccions.",
    "sec:competences": "només es tenen en compte competències i resultats d'aprenentatge.",
    "sec:course_info": "només es tenen en compte títol, descripció i continguts de l'assignatura.",
    "sec:references": "només es tenen en compte bibliografia i referències.",
    "default": "s'aplica el criteri de secció seleccionat sobre la guia docent."
  }
};

const state = {
  apiBase: "",
  apiVersion: "",
  apiVersionMeta: null,
  apiDetailedMeta: null,
  apiScrapingPlatforms: [],
  apiScrapingDate: null,
  centres: [],
  centreByCode: new Map(),
  programmesByCentreCode: new Map(),
  programmeByKey: new Map(),
  systemOptions: [],
  sectionOptions: [],
  centreCache: new Map(),
  programmeCache: new Map(),
  renderToken: 0,
  lastRows: [],
  lastRenderContext: null,
  paletteIndex: 0,
  wordLimit: DEFAULT_WORDS_TO_RENDER,
  uiStrings: DEFAULT_UI_STRINGS
};

let resizeDebounceTimer = null;
let wordLimitDebounceTimer = null;
let pendingMobileAutoScroll = false;

function setStatus(message, isError) {
  statusEl.textContent = message || "";
  statusEl.style.color = isError ? "#c0392b" : "";
}

function mergeDeepObjects(base, override) {
  const result = { ...(base || {}) };
  const source = override || {};
  Object.keys(source).forEach((key) => {
    const baseValue = result[key];
    const overrideValue = source[key];
    const canMerge = baseValue && overrideValue
      && typeof baseValue === "object"
      && typeof overrideValue === "object"
      && !Array.isArray(baseValue)
      && !Array.isArray(overrideValue);
    result[key] = canMerge ? mergeDeepObjects(baseValue, overrideValue) : overrideValue;
  });
  return result;
}

function normalizeWhitespace(value) {
  return String(value || "").replace(/\s+/g, " ").trim();
}

function escapeHtml(value) {
  return String(value == null ? "" : value)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function formatTemplate(template, values) {
  return String(template || "").replace(/\{(\w+)\}/g, (_, key) => {
    const mapped = values && Object.prototype.hasOwnProperty.call(values, key) ? values[key] : "";
    return mapped == null ? "" : String(mapped);
  });
}

function formatCount(value) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed)) return "0";
  return parsed.toLocaleString("ca-ES");
}

function parseDateCandidate(value) {
  if (value == null || value === "") return null;
  const candidateDate = new Date(value);
  return Number.isFinite(candidateDate.getTime()) ? candidateDate : null;
}

function formatDateCa(value) {
  const parsed = parseDateCandidate(value);
  return parsed ? parsed.toLocaleString("ca-ES") : "desconeguda";
}

function getSelectedOptionLabel(selectEl) {
  const option = selectEl && selectEl.selectedIndex >= 0 ? selectEl.options[selectEl.selectedIndex] : null;
  return normalizeWhitespace(option?.textContent || "");
}

function getLocalizedOptionLabel(kind, optionId, fallbackLabel) {
  const catalog = kind === "system"
    ? state.uiStrings?.system_labels
    : state.uiStrings?.section_labels;
  const mapped = catalog?.[String(optionId || "")];
  return normalizeWhitespace(mapped || fallbackLabel || optionId || "");
}

function getSystemExplanationText(systemId) {
  return normalizeWhitespace(state.uiStrings?.system_explanations?.[String(systemId || "")]
    || state.uiStrings?.system_explanations?.default
    || "");
}

function getSystemModeText(systemId) {
  return normalizeWhitespace(state.uiStrings?.system_modes?.[String(systemId || "")]
    || state.uiStrings?.system_modes?.default
    || "");
}

function getSectionExplanationText(sectionId) {
  return normalizeWhitespace(state.uiStrings?.section_explanations?.[String(sectionId || "")]
    || state.uiStrings?.section_explanations?.default
    || "");
}

function getSystemQualityText(systemId) {
  return normalizeWhitespace(state.uiStrings?.system_quality_notes?.[String(systemId || "")]
    || state.uiStrings?.system_quality_notes?.default
    || "");
}

function setPanelText(element, text) {
  element.textContent = normalizeWhitespace(text);
}

function setPanelHtml(element, html) {
  element.innerHTML = String(html || "");
}

function renderSelectionPanelEmpty() {
  const panelStrings = state.uiStrings?.panel || {};
  setPanelText(selectionPanelTitleEl, panelStrings.empty_title || DEFAULT_UI_STRINGS.panel.empty_title);
  setPanelText(selectionPanelScopeEl, panelStrings.empty_scope || DEFAULT_UI_STRINGS.panel.empty_scope);
  setPanelText(selectionPanelCoursesEl, "");
  setPanelText(selectionPanelSystemEl, "");
  setPanelText(selectionPanelSectionEl, "");
  setPanelText(selectionPanelLimitEl, "");
  setPanelText(selectionPanelPaletteEl, "");
}

function renderSelectionPanelError() {
  const panelStrings = state.uiStrings?.panel || {};
  setPanelText(selectionPanelTitleEl, panelStrings.error_title || DEFAULT_UI_STRINGS.panel.error_title);
  setPanelText(selectionPanelScopeEl, panelStrings.error_scope || DEFAULT_UI_STRINGS.panel.error_scope);
  setPanelText(selectionPanelCoursesEl, "");
  setPanelText(selectionPanelSystemEl, "");
  setPanelText(selectionPanelSectionEl, "");
  setPanelText(selectionPanelLimitEl, "");
  setPanelText(selectionPanelPaletteEl, "");
}

function isCompactWordcloudLayout() {
  return window.matchMedia("(max-width: 1000px)").matches;
}

function scrollToWordcloud() {
  const target = document.querySelector(".wordcloud-wrapper");
  if (!target) return;
  target.scrollIntoView({
    behavior: "smooth",
    block: "start"
  });
}

function updateMobileCloudHintVisibility() {
  if (!mobileCloudHintEl) return;
  const hasFacultySelection = Boolean(String(facultySelect.value || ""));
  mobileCloudHintEl.hidden = !(isCompactWordcloudLayout() && !hasFacultySelection);
}

function setIntroPanelExpanded(isExpanded) {
  if (!introToggleBtn || !introPanelEl) return;
  introPanelEl.hidden = !isExpanded;
  introToggleBtn.setAttribute("aria-expanded", String(!!isExpanded));
}

function updateSelectionPanel(context) {
  if (!context?.centreCode) {
    renderSelectionPanelEmpty();
    return;
  }

  const templates = state.uiStrings?.templates || DEFAULT_UI_STRINGS.templates;
  const centre = state.centreByCode.get(String(context.centreCode || ""));
  const centreName = normalizeWhitespace(centre?.centre_name || context.detail?.centre?.name || "");
  const programme = context.showCentre ? null : state.programmeByKey.get(String(context.selectedDegree || ""));
  const programmeName = normalizeWhitespace(programme?.programme_name || context.detail?.programme?.name || "");

  const systemLabel = getSelectedOptionLabel(systemSelect) || context.selectedSystem;
  const sectionLabel = getSelectedOptionLabel(sectionSelect) || context.selectedSection;
  const systemHelp = getSystemExplanationText(context.selectedSystem);
  const systemMode = getSystemModeText(context.selectedSystem);
  const systemQuality = getSystemQualityText(context.selectedSystem);
  const sectionHelp = getSectionExplanationText(context.selectedSection);

  const nCourses = Number(context.detail?.n_courses || centre?.n_courses || 0);
  const nProgrammes = Number(centre?.n_programmes || 0);
  const paletteLabel = normalizeWhitespace(getActivePalette()?.label || "-");
  const wordLimitLabel = formatCount(state.wordLimit);

  const title = context.showCentre
    ? formatTemplate(templates.title_centre, { centre: centreName })
    : formatTemplate(templates.title_programme, { programme: programmeName, centre: centreName });

  const introParagraphTemplate = context.showCentre
    ? (templates.narrative_intro_centre || DEFAULT_UI_STRINGS.templates.narrative_intro_centre)
    : (templates.narrative_intro_programme || DEFAULT_UI_STRINGS.templates.narrative_intro_programme);
  const introParagraph = formatTemplate(introParagraphTemplate, {
    centre: `<strong>${escapeHtml(centreName)}</strong>`,
    programme: `<strong>${escapeHtml(programmeName)}</strong>`,
    n_courses: `<strong>${escapeHtml(formatCount(nCourses))}</strong>`,
    n_programmes: `<strong>${escapeHtml(formatCount(nProgrammes))}</strong>`
  });
  const methodParagraph = formatTemplate(
    templates.narrative_method || DEFAULT_UI_STRINGS.templates.narrative_method,
    {
      system_label: `<strong>${escapeHtml(systemLabel)}</strong>`,
      system_mode: `<strong>${escapeHtml(systemMode)}</strong>`,
      system_help: escapeHtml(systemHelp),
      system_quality: escapeHtml(systemQuality)
    }
  );
  const contextParagraph = formatTemplate(
    templates.narrative_context || DEFAULT_UI_STRINGS.templates.narrative_context,
    {
      section_label: `<strong>${escapeHtml(sectionLabel)}</strong>`,
      section_help: escapeHtml(sectionHelp),
      word_limit: `<strong>${escapeHtml(wordLimitLabel)}</strong>`,
      palette_label: `<strong>${escapeHtml(paletteLabel)}</strong>`
    }
  );
  const provenanceParagraph = state.apiScrapingPlatforms.length
    ? formatTemplate(
      templates.narrative_provenance || DEFAULT_UI_STRINGS.templates.narrative_provenance,
      {
        platforms: `<strong>${state.apiScrapingPlatforms.map(name => escapeHtml(name)).join(", ")}</strong>`
      }
    )
    : "";
  const scrapingDateRaw = state.apiScrapingDate || state.apiVersionMeta?.generated_at || null;
  const scrapingDateParagraph = scrapingDateRaw
    ? formatTemplate(
      templates.narrative_scraping_date || DEFAULT_UI_STRINGS.templates.narrative_scraping_date,
      {
        scraping_date: `<strong>${escapeHtml(formatDateCa(scrapingDateRaw))}</strong>`
      }
    )
    : (templates.narrative_scraping_date_unknown
      || DEFAULT_UI_STRINGS.templates.narrative_scraping_date_unknown);

  setPanelText(selectionPanelTitleEl, title);
  setPanelHtml(selectionPanelScopeEl, introParagraph);
  setPanelHtml(selectionPanelCoursesEl, methodParagraph);
  setPanelHtml(selectionPanelSystemEl, contextParagraph);
  setPanelHtml(selectionPanelSectionEl, provenanceParagraph);
  setPanelHtml(selectionPanelLimitEl, scrapingDateParagraph);
  setPanelText(selectionPanelPaletteEl, "");
}

async function loadUiStrings() {
  const candidates = Array.from(new Set([WORDCLOUD_STRINGS_URL, WORDCLOUD_STRINGS_FALLBACK_URL].filter(Boolean)));
  for (const url of candidates) {
    try {
      const loadedStrings = await fetchJson(url);
      state.uiStrings = mergeDeepObjects(DEFAULT_UI_STRINGS, loadedStrings || {});
      return;
    } catch (err) {
      // Fallback handled by next candidate / defaults.
    }
  }
  state.uiStrings = DEFAULT_UI_STRINGS;
}

function setRecolorButtonEnabled(isEnabled) {
  recolorBtn.disabled = !isEnabled;
}

function setSelectorsDisabled(isDisabled) {
  facultySelect.disabled = isDisabled;
  systemSelect.disabled = isDisabled;
  sectionSelect.disabled = isDisabled;
  wordLimitRange.disabled = isDisabled;
  if (isDisabled) {
    degreeSelect.disabled = true;
    setRecolorButtonEnabled(false);
    return;
  }
  degreeSelect.disabled = !String(facultySelect.value || "");
}

function randomIndex(max) {
  return Math.floor(Math.random() * max);
}

function clamp(value, min, max) {
  return Math.min(max, Math.max(min, value));
}

function normalizeHexColor(hex) {
  const raw = String(hex || "").trim().replace(/^#/, "");
  if (raw.length === 3) {
    return raw.split("").map(ch => ch + ch).join("");
  }
  if (raw.length === 6) return raw;
  return "1f4e79";
}

function hexToRgb(hex) {
  const normalized = normalizeHexColor(hex);
  const value = Number.parseInt(normalized, 16);
  return {
    r: (value >> 16) & 255,
    g: (value >> 8) & 255,
    b: value & 255
  };
}

function rgbToHex(r, g, b) {
  const toHex = (n) => clamp(Math.round(n), 0, 255).toString(16).padStart(2, "0");
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}

function rgbToHsl(r, g, b) {
  const rr = clamp(r, 0, 255) / 255;
  const gg = clamp(g, 0, 255) / 255;
  const bb = clamp(b, 0, 255) / 255;
  const max = Math.max(rr, gg, bb);
  const min = Math.min(rr, gg, bb);
  const delta = max - min;

  let h = 0;
  if (delta > 0) {
    if (max === rr) h = ((gg - bb) / delta) % 6;
    else if (max === gg) h = (bb - rr) / delta + 2;
    else h = (rr - gg) / delta + 4;
    h *= 60;
    if (h < 0) h += 360;
  }

  const l = (max + min) / 2;
  const s = delta === 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));

  return {
    h,
    s: s * 100,
    l: l * 100
  };
}

function hslToRgb(h, s, l) {
  const hh = ((h % 360) + 360) % 360;
  const ss = clamp(s, 0, 100) / 100;
  const ll = clamp(l, 0, 100) / 100;

  const c = (1 - Math.abs(2 * ll - 1)) * ss;
  const x = c * (1 - Math.abs((hh / 60) % 2 - 1));
  const m = ll - c / 2;

  let rr = 0;
  let gg = 0;
  let bb = 0;

  if (hh < 60) {
    rr = c; gg = x; bb = 0;
  } else if (hh < 120) {
    rr = x; gg = c; bb = 0;
  } else if (hh < 180) {
    rr = 0; gg = c; bb = x;
  } else if (hh < 240) {
    rr = 0; gg = x; bb = c;
  } else if (hh < 300) {
    rr = x; gg = 0; bb = c;
  } else {
    rr = c; gg = 0; bb = x;
  }

  return {
    r: (rr + m) * 255,
    g: (gg + m) * 255,
    b: (bb + m) * 255
  };
}

function transformHexColor(hex, shiftH, shiftS, shiftL) {
  const { r, g, b } = hexToRgb(hex);
  const { h, s, l } = rgbToHsl(r, g, b);
  const nextH = h + shiftH;
  const nextS = clamp(s + shiftS, 28, 95);
  const nextL = clamp(l + shiftL, 18, 78);
  const rgb = hslToRgb(nextH, nextS, nextL);
  return rgbToHex(rgb.r, rgb.g, rgb.b);
}

function buildExpandedPalette(baseColors, targetSize) {
  const source = (Array.isArray(baseColors) ? baseColors : []).filter(Boolean);
  if (!source.length) return ["#1f4e79"];

  const transforms = [
    { h: 0, s: 0, l: 0 },
    { h: 10, s: 12, l: -8 },
    { h: -12, s: 8, l: 10 },
    { h: 22, s: -10, l: 4 },
    { h: -24, s: -6, l: -10 },
    { h: 32, s: 16, l: 0 }
  ];

  const expanded = [];
  const seen = new Set();
  const pushColor = (color) => {
    const key = String(color || "").toLowerCase();
    if (!key || seen.has(key)) return;
    seen.add(key);
    expanded.push(color);
  };

  for (const transform of transforms) {
    for (const color of source) {
      pushColor(transformHexColor(color, transform.h, transform.s, transform.l));
    }
  }

  const needed = Math.max(targetSize, source.length * 2);
  for (let i = 0; expanded.length < needed && i < needed * 3; i += 1) {
    const base = source[i % source.length];
    const jitterH = ((i * 37) % 49) - 24;
    const jitterS = ((i * 17) % 19) - 9;
    const jitterL = ((i * 13) % 21) - 10;
    pushColor(transformHexColor(base, jitterH, jitterS, jitterL));
  }

  return expanded.length ? expanded : source.map(c => `#${normalizeHexColor(c)}`);
}

function greatestCommonDivisor(a, b) {
  let x = Math.abs(Math.floor(a));
  let y = Math.abs(Math.floor(b));
  while (y) {
    const temp = y;
    y = x % y;
    x = temp;
  }
  return x || 1;
}

function getCoprimeStride(length) {
  if (length <= 1) return 1;
  let stride = Math.floor(length / 2) + 1;
  while (stride < length) {
    if (greatestCommonDivisor(stride, length) === 1) return stride;
    stride += 1;
  }
  return 1;
}

function buildWordColorMap(wordList, baseColors) {
  const expandedColors = buildExpandedPalette(baseColors, Math.max(24, wordList.length * 2));
  const colorMap = new Map();
  const stride = getCoprimeStride(expandedColors.length);

  wordList.forEach(([word], index) => {
    const slot = (index * stride) % expandedColors.length;
    colorMap.set(word, expandedColors[slot]);
  });

  return { colorMap, expandedColors };
}

function clampWordLimit(value) {
  const parsed = Number(value);
  if (!Number.isFinite(parsed)) return DEFAULT_WORDS_TO_RENDER;
  return Math.min(MAX_WORDS_TO_RENDER, Math.max(MIN_WORDS_TO_RENDER, Math.round(parsed)));
}

function syncWordLimitUi() {
  state.wordLimit = clampWordLimit(state.wordLimit);
  wordLimitRange.value = String(state.wordLimit);
  wordLimitValue.textContent = String(state.wordLimit);
}

function getActivePalette() {
  return WORDCLOUD_PALETTES[state.paletteIndex] || WORDCLOUD_PALETTES[0];
}

function pickNextPalette() {
  if (!WORDCLOUD_PALETTES.length) return [];
  let index = randomIndex(WORDCLOUD_PALETTES.length);
  if (WORDCLOUD_PALETTES.length > 1 && index === state.paletteIndex) {
    index = (index + 1) % WORDCLOUD_PALETTES.length;
  }
  state.paletteIndex = index;
  return getActivePalette();
}

function formatRenderStatus(renderedCount, totalCount) {
  return `Mostrant ${renderedCount} termes (de ${totalCount}, límit ${state.wordLimit}).`;
}

function resizeCanvas() {
  const container = document.querySelector(".wordcloud-wrapper");
  if (!container) return { width: 300, height: 320 };
  const rect = container.getBoundingClientRect();
  const width = Math.max(300, Math.floor(container.clientWidth || rect.width));
  const height = Math.max(320, Math.floor(container.clientHeight || rect.height));
  canvas.width = width;
  canvas.height = height;
  return { width, height };
}

function syncWordcloudWrapperHeight() {
  const wordcloudWrapper = document.querySelector(".wordcloud-wrapper");
  if (!wordcloudWrapper) return;
  const targetHeight = Math.max(340, Math.min(window.innerHeight * 0.62, 640));
  wordcloudWrapper.style.height = `${Math.round(targetHeight)}px`;
}

function drawWordCloud(featureRows) {
  const wordLimit = clampWordLimit(state.wordLimit);
  const rawWordList = (featureRows || [])
    .filter(row => row && typeof row.feature === "string" && row.feature.trim().length > 0 && typeof row.n_hits === "number" && row.n_hits > 0)
    .sort((a, b) => b.n_hits - a.n_hits)
    .slice(0, wordLimit)
    .map(row => [row.feature.trim(), row.n_hits]);

  const { width } = resizeCanvas();

  const context = canvas.getContext("2d");
  if (context) {
    context.clearRect(0, 0, canvas.width, canvas.height);
  }

  if (!rawWordList.length) {
    return 0;
  }

  const rankSpread = rawWordList.length <= 30 ? 0.55 : (rawWordList.length <= 50 ? 0.35 : 0.2);
  const wordList = rawWordList.map(([word, hits], index) => {
    const rankNorm = rawWordList.length > 1 ? 1 - (index / (rawWordList.length - 1)) : 1;
    const adjustedHits = hits * (1 + rankNorm * rankSpread);
    return [word, adjustedHits];
  });

  const maxFrequency = Math.max(...wordList.map(w => w[1]));
  const minFrequency = Math.min(...wordList.map(w => w[1]));
  const maxLog = Math.log1p(maxFrequency);
  const minLog = Math.log1p(minFrequency);
  const logRange = Math.max(0.000001, maxLog - minLog);
  const isDenseCloud = rawWordList.length >= 60;
  const isSparseCloud = rawWordList.length <= 30;

  // Keep weight lower bound below minSize so shrinkToFit can terminate.
  const minWeight = Math.max(2, Math.floor(MIN_WORD_SIZE * 0.5));
  const baseMaxWeight = Math.max(minWeight + 10, width * 0.085);
  const spreadMultiplier = isSparseCloud ? 1.35 : (isDenseCloud ? 1 : 1.18);
  const maxWeight = Math.max(minWeight + 10, baseMaxWeight * spreadMultiplier);
  const exponent = isSparseCloud ? 1.55 : (isDenseCloud ? 1.2 : 1.35);

  const activePalette = getActivePalette();
  const activeColors = Array.isArray(activePalette?.colors) ? activePalette.colors : [];
  const { colorMap, expandedColors } = buildWordColorMap(rawWordList, activeColors);

  WordCloud(canvas, {
    list: wordList,
    gridSize: Math.max(5, Math.round(width * 0.0065)),
    weightFactor: function(size) {
      if (maxLog <= 0) return minWeight;
      // Adaptive scale per active limit: sparse clouds get extra contrast.
      const normalizedRaw = (Math.log1p(Math.max(0, size)) - minLog) / logRange;
      const normalized = Math.pow(clamp(normalizedRaw, 0, 1), exponent);
      return minWeight + normalized * (maxWeight - minWeight);
    },
    fontFamily: "Arial",
    color: function(word) {
      const key = String(word || "");
      if (colorMap.has(key)) return colorMap.get(key);
      if (!expandedColors.length) return "#1f4e79";
      return expandedColors[randomIndex(expandedColors.length)];
    },
    backgroundColor: "#fff",
    rotateRatio: 0,
    drawOutOfBound: false,
    shrinkToFit: true,
    minSize: MIN_WORD_SIZE,
    maxSize: MAX_WORD_SIZE,
    shape: "square",
    ellipticity: 0.6,
    clearCanvas: true,
    wait: 10,
    abortThreshold: 1800,
    abort: function() {
      console.warn("Word cloud render aborted due timeout.");
    }
  });

  return wordList.length;
}

function joinUrl(base, path) {
  const cleanPath = String(path || "").replace(/^\/+/, "");
  return `${base}/${cleanPath}`;
}

async function fetchJson(url) {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Error carregant ${url}: ${response.status}`);
  }
  return response.json();
}

async function fetchApiJson(relativePath) {
  const url = joinUrl(state.apiBase, relativePath);
  return fetchJson(url);
}

function addOption(selectEl, value, label) {
  const option = document.createElement("option");
  option.value = String(value);
  option.textContent = normalizeWhitespace(label);
  selectEl.appendChild(option);
}

function programmeKey(centreCode, programmeCode) {
  return `${String(centreCode)}::${String(programmeCode)}`;
}

function populateFacultySelect(selectedCentreCode) {
  facultySelect.innerHTML = "";

  const placeholder = document.createElement("option");
  placeholder.value = "";
  placeholder.textContent = "Facultat/Escola (obligatori)";
  placeholder.disabled = true;
  placeholder.selected = true;
  facultySelect.appendChild(placeholder);

  state.centres.forEach(c => {
    addOption(facultySelect, c.centre_code, c.centre_name);
  });

  if (selectedCentreCode && state.centreByCode.has(String(selectedCentreCode))) {
    facultySelect.value = String(selectedCentreCode);
  } else {
    facultySelect.value = "";
  }
}

function populateDegreeSelect(centreCode, selectedProgrammeKey) {
  degreeSelect.innerHTML = "";

  const placeholder = document.createElement("option");
  placeholder.value = "";
  placeholder.textContent = centreCode
    ? 'Ensenyament (opcional): selecciona o tria "Tots"'
    : "Ensenyament (opcional): selecciona una Facultat/Escola primer";
  placeholder.disabled = true;
  placeholder.selected = true;
  degreeSelect.appendChild(placeholder);

  if (!centreCode) {
    degreeSelect.disabled = true;
    degreeSelect.value = "";
    return;
  }

  degreeSelect.disabled = false;
  addOption(degreeSelect, "ALL", "Tots");

  const programmes = state.programmesByCentreCode.get(String(centreCode)) || [];
  programmes.forEach(p => {
    addOption(degreeSelect, programmeKey(p.centre_code, p.programme_code), p.programme_name);
  });

  if (selectedProgrammeKey && selectedProgrammeKey !== "ALL" && state.programmeByKey.has(selectedProgrammeKey)) {
    degreeSelect.value = selectedProgrammeKey;
  } else if (selectedProgrammeKey === "ALL") {
    degreeSelect.value = "ALL";
  } else {
    degreeSelect.value = "";
  }
}

function populateSystemSelect(selectedId) {
  systemSelect.innerHTML = "";
  state.systemOptions.forEach(opt => {
    addOption(systemSelect, opt.id, getLocalizedOptionLabel("system", opt.id, opt.label));
  });
  const fallback = state.systemOptions[0] ? state.systemOptions[0].id : "";
  systemSelect.value = state.systemOptions.some(opt => opt.id === selectedId) ? selectedId : fallback;
}

function populateSectionSelect(selectedId) {
  sectionSelect.innerHTML = "";
  state.sectionOptions.forEach(opt => {
    addOption(sectionSelect, opt.id, getLocalizedOptionLabel("section", opt.id, opt.label));
  });
  const fallback = state.sectionOptions[0] ? state.sectionOptions[0].id : "";
  sectionSelect.value = state.sectionOptions.some(opt => opt.id === selectedId) ? selectedId : fallback;
}

function getFeatureRows(detailJson, systemId, sectionId) {
  const rows = detailJson?.by_set?.feature?.[systemId]?.[sectionId];
  if (!Array.isArray(rows)) return [];
  return rows
    .map(row => ({
      feature: row?.feature,
      n_hits: Number(row?.n_hits)
    }))
    .filter(row => typeof row.feature === "string" && row.feature.trim().length > 0 && Number.isFinite(row.n_hits) && row.n_hits > 0);
}

function normalizeSystemId(systemId) {
  if (systemId === "ens:equal") return "sys:ensemble_equal";
  if (systemId === "ens:third") return "sys:ensemble_third";
  if (systemId === "ens:triple") return "sys:ensemble_triple";
  return systemId;
}

function resetAnalysisFiltersToDefaults() {
  populateSystemSelect(DEFAULT_SYSTEM_ID);
  populateSectionSelect(DEFAULT_SECTION_ID);
}

function extractScrapingPlatforms(metaJson) {
  const rawPlatforms = metaJson?.generated_from?.scraping_meta?.scraping_context?.platforms;
  if (!Array.isArray(rawPlatforms)) return [];
  return rawPlatforms
    .map(item => normalizeWhitespace(item?.name))
    .filter(Boolean);
}

function extractScrapingDate(metaJson) {
  const scrapingMeta = metaJson?.generated_from?.scraping_meta || {};
  const scrapingContext = scrapingMeta?.scraping_context || {};
  const platforms = Array.isArray(scrapingContext?.platforms) ? scrapingContext.platforms : [];

  const platformCandidates = platforms.flatMap((item) => [
    item?.generated_at,
    item?.scraped_at,
    item?.snapshot_at,
    item?.updated_at,
    item?.date,
    item?.captured_at
  ]);

  const candidates = [
    scrapingMeta?.generated_at,
    scrapingMeta?.scraped_at,
    scrapingMeta?.snapshot_at,
    scrapingMeta?.updated_at,
    scrapingMeta?.date,
    scrapingMeta?.captured_at,
    scrapingContext?.generated_at,
    scrapingContext?.scraped_at,
    scrapingContext?.snapshot_at,
    scrapingContext?.updated_at,
    scrapingContext?.date,
    scrapingContext?.captured_at,
    metaJson?.generated_at,
    metaJson?.updated_at,
    metaJson?.created_at,
    ...platformCandidates
  ].filter((value) => value != null && value !== "");

  for (const candidate of candidates) {
    const parsed = parseDateCandidate(candidate);
    if (parsed) return parsed.toISOString();
  }

  return null;
}

async function resolveApiBaseAndVersion() {
  let lastError = null;

  for (const base of API_BASE_CANDIDATES) {
    try {
      const versions = await fetchJson(joinUrl(base, "versions.json"));
      const latestVersion = versions?.latest || versions?.versions?.[0]?.id;
      if (!latestVersion) throw new Error(`versions.json sense 'latest' a ${base}`);

      state.apiBase = base;
      state.apiVersion = latestVersion;
      state.apiVersionMeta = (versions.versions || []).find(v => v.id === latestVersion) || null;
      state.apiDetailedMeta = null;
      state.apiScrapingPlatforms = [];
      state.apiScrapingDate = null;

      const metaPathFromVersions = state.apiVersionMeta?.meta;
      const metaCandidates = [
        metaPathFromVersions,
        `${latestVersion}/meta.json`
      ].filter(Boolean);

      for (const metaPath of metaCandidates) {
        try {
          const metaJson = await fetchApiJson(metaPath);
          state.apiDetailedMeta = metaJson;
          state.apiScrapingPlatforms = extractScrapingPlatforms(metaJson);
          state.apiScrapingDate = extractScrapingDate(metaJson);
          break;
        } catch (metaErr) {
          // Keep processing with available metadata.
        }
      }

      if (!state.apiScrapingDate && state.apiVersionMeta?.generated_at) {
        state.apiScrapingDate = state.apiVersionMeta.generated_at;
      }

      return;
    } catch (err) {
      lastError = err;
    }
  }

  throw lastError || new Error("No s'ha pogut connectar amb cap endpoint de l'API");
}

async function loadIndexes() {
  const versionPrefix = state.apiVersion;
  const [centres, programmes, systemsJson, sectionsJson] = await Promise.all([
    fetchApiJson(`${versionPrefix}/index/centres.json`),
    fetchApiJson(`${versionPrefix}/index/programmes.json`),
    fetchApiJson(`${versionPrefix}/index/systems.json`),
    fetchApiJson(`${versionPrefix}/index/sections.json`)
  ]);

  state.centres = Array.isArray(centres)
    ? centres
      .map(c => ({
        ...c,
        centre_name: normalizeWhitespace(c?.centre_name)
      }))
      .sort((a, b) => String(a.centre_name || "").localeCompare(String(b.centre_name || ""), "ca"))
    : [];
  state.centreByCode = new Map(state.centres.map(c => [String(c.centre_code), c]));

  state.programmesByCentreCode = new Map();
  state.programmeByKey = new Map();
  (Array.isArray(programmes) ? programmes : []).forEach(rawProgramme => {
    const p = {
      ...rawProgramme,
      centre_name: normalizeWhitespace(rawProgramme?.centre_name),
      programme_name: normalizeWhitespace(rawProgramme?.programme_name)
    };

    const centreCode = String(p?.centre_code || "");
    const pKey = programmeKey(p?.centre_code, p?.programme_code);
    if (!centreCode) return;

    if (!state.programmesByCentreCode.has(centreCode)) {
      state.programmesByCentreCode.set(centreCode, []);
    }
    state.programmesByCentreCode.get(centreCode).push(p);
    state.programmeByKey.set(pKey, p);
  });

  for (const [centreCode, items] of state.programmesByCentreCode.entries()) {
    const sorted = items.slice().sort((a, b) => String(a.programme_name || "").localeCompare(String(b.programme_name || ""), "ca"));
    state.programmesByCentreCode.set(centreCode, sorted);
  }

  state.systemOptions = Array.isArray(systemsJson?.system_options)
    ? systemsJson.system_options.map(opt => ({ ...opt, label: normalizeWhitespace(opt?.label) }))
    : [];
  state.sectionOptions = Array.isArray(sectionsJson?.section_options)
    ? sectionsJson.section_options.map(opt => ({ ...opt, label: normalizeWhitespace(opt?.label) }))
    : [];
}

function renderApiInfo() {
  const generatedAt = state.apiVersionMeta?.generated_at;
  const generatedLabel = generatedAt ? new Date(generatedAt).toLocaleString("ca-ES") : "data desconeguda";
  const safeBase = escapeHtml(state.apiBase);
  const safeVersion = escapeHtml(state.apiVersion);
  const safeGenerated = escapeHtml(generatedLabel);
  const safePlatforms = state.apiScrapingPlatforms.map(name => escapeHtml(name)).join(", ");
  const provenance = safePlatforms
    ? ` · Fonts de captura: <strong>${safePlatforms}</strong>`
    : "";

  apiInfoEl.innerHTML = `Font de dades: <a href="${safeBase}" target="_blank" rel="noopener noreferrer" class="wordcloud-source-link">${safeBase}</a> (${safeVersion}, snapshot ${safeGenerated})${provenance}`;
}

async function getCentreDetail(centreCode) {
  const key = String(centreCode || "");
  if (!key) throw new Error("Centre no seleccionat");
  if (state.centreCache.has(key)) return state.centreCache.get(key);

  const centre = state.centreByCode.get(key);
  if (!centre?.json) throw new Error(`Centre sense fitxer de detall: ${key}`);

  const detail = await fetchApiJson(`${state.apiVersion}/${centre.json}`);
  state.centreCache.set(key, detail);
  return detail;
}

async function getProgrammeDetail(programmeId) {
  const key = String(programmeId || "");
  if (!key) throw new Error("Ensenyament no seleccionat");
  if (state.programmeCache.has(key)) return state.programmeCache.get(key);

  const programme = state.programmeByKey.get(key);
  if (!programme?.json) throw new Error(`Ensenyament sense fitxer de detall: ${key}`);

  const detail = await fetchApiJson(`${state.apiVersion}/${programme.json}`);
  state.programmeCache.set(key, detail);
  return detail;
}

async function renderCurrentSelection() {
  const centreCode = String(facultySelect.value || "");
  updateMobileCloudHintVisibility();

  if (!centreCode) {
    state.lastRows = [];
    state.lastRenderContext = null;
    setRecolorButtonEnabled(false);
    drawWordCloud([]);
    renderSelectionPanelEmpty();
    setStatus("Selecciona una Facultat/Escola per veure el núvol de paraules.", false);
    return;
  }

  const token = ++state.renderToken;
  setStatus("Carregant dades...");

  try {
    const selectedSystem = normalizeSystemId(String(systemSelect.value || DEFAULT_SYSTEM_ID));
    const selectedSection = String(sectionSelect.value || DEFAULT_SECTION_ID);
    const selectedDegree = String(degreeSelect.value || "");
    const showCentre = selectedDegree === "" || selectedDegree === "ALL";

    const detail = showCentre
      ? await getCentreDetail(centreCode)
      : await getProgrammeDetail(selectedDegree);

    if (token !== state.renderToken) return;

    const rows = getFeatureRows(detail, selectedSystem, selectedSection);
    state.lastRows = rows;
    state.lastRenderContext = {
      detail,
      showCentre,
      centreCode,
      selectedDegree,
      selectedSystem,
      selectedSection
    };
    updateSelectionPanel(state.lastRenderContext);

    const renderedCount = drawWordCloud(rows);

    if (!rows.length) {
      setRecolorButtonEnabled(false);
      setStatus("No hi ha termes per a aquesta combinació de filtres.", false);
      return;
    }

    setRecolorButtonEnabled(true);
    setStatus(formatRenderStatus(renderedCount, rows.length), false);

    if (pendingMobileAutoScroll && isCompactWordcloudLayout()) {
      pendingMobileAutoScroll = false;
      setTimeout(scrollToWordcloud, 110);
    }
  } catch (err) {
    if (token !== state.renderToken) return;
    console.error(err);
    state.lastRows = [];
    state.lastRenderContext = null;
    setRecolorButtonEnabled(false);
    drawWordCloud([]);
    renderSelectionPanelError();
    setStatus("Error carregant les dades del núvol de paraules.", true);
  }
}

function setFatalErrorState() {
  facultySelect.innerHTML = '<option value="">Error carregant centres</option>';
  degreeSelect.innerHTML = '<option value="">Error carregant ensenyaments</option>';
  systemSelect.innerHTML = '<option value="">Error carregant sistemes</option>';
  sectionSelect.innerHTML = '<option value="">Error carregant seccions</option>';
  state.lastRenderContext = null;
  setRecolorButtonEnabled(false);
  setSelectorsDisabled(true);
  renderSelectionPanelError();
}

document.addEventListener("DOMContentLoaded", async () => {
  updateMobileCloudHintVisibility();
  if (mobileCloudHintEl) {
    mobileCloudHintEl.addEventListener("click", scrollToWordcloud);
  }

  setIntroPanelExpanded(false);
  if (introToggleBtn && introPanelEl) {
    introToggleBtn.addEventListener("click", () => {
      const expanded = introToggleBtn.getAttribute("aria-expanded") === "true";
      setIntroPanelExpanded(!expanded);
    });
  }

  syncWordcloudWrapperHeight();
  state.paletteIndex = randomIndex(WORDCLOUD_PALETTES.length);
  syncWordLimitUi();
  renderSelectionPanelEmpty();

  setSelectorsDisabled(true);
  setRecolorButtonEnabled(false);
  setStatus("Inicialitzant dades de l'API...");

  try {
    await resolveApiBaseAndVersion();
    await loadUiStrings();
    await loadIndexes();

    resetAnalysisFiltersToDefaults();

    populateFacultySelect("");
    populateDegreeSelect("", "");

    renderApiInfo();
    setSelectorsDisabled(false);
    await renderCurrentSelection();
  } catch (err) {
    console.error(err);
    setFatalErrorState();
    setStatus("No s'ha pogut inicialitzar la càrrega de dades de l'API.", true);
  }

  facultySelect.addEventListener("change", () => {
    pendingMobileAutoScroll = Boolean(String(facultySelect.value || "")) && isCompactWordcloudLayout();
    populateDegreeSelect(facultySelect.value, "");
    resetAnalysisFiltersToDefaults();
    renderCurrentSelection();
  });

  degreeSelect.addEventListener("change", () => {
    resetAnalysisFiltersToDefaults();
    renderCurrentSelection();
  });

  systemSelect.addEventListener("change", () => {
    renderCurrentSelection();
  });

  sectionSelect.addEventListener("change", () => {
    renderCurrentSelection();
  });

  recolorBtn.addEventListener("click", () => {
    if (!state.lastRows.length) return;
    const palette = pickNextPalette();
    const renderedCount = drawWordCloud(state.lastRows);
    const paletteLabel = palette?.label ? `Paleta ${palette.label}. ` : "";
    if (state.lastRenderContext) updateSelectionPanel(state.lastRenderContext);
    setStatus(`${paletteLabel}${formatRenderStatus(renderedCount, state.lastRows.length)}`, false);
  });

  wordLimitRange.addEventListener("input", () => {
    state.wordLimit = clampWordLimit(wordLimitRange.value);
    syncWordLimitUi();

    if (wordLimitDebounceTimer) clearTimeout(wordLimitDebounceTimer);
    if (!state.lastRows.length) return;

    wordLimitDebounceTimer = setTimeout(() => {
      const renderedCount = drawWordCloud(state.lastRows);
      if (state.lastRenderContext) updateSelectionPanel(state.lastRenderContext);
      setStatus(`Límit ajustat. ${formatRenderStatus(renderedCount, state.lastRows.length)}`, false);
    }, 120);
  });

  window.addEventListener("resize", () => {
    updateMobileCloudHintVisibility();

    if (resizeDebounceTimer) clearTimeout(resizeDebounceTimer);
    resizeDebounceTimer = setTimeout(() => {
      syncWordcloudWrapperHeight();
      renderCurrentSelection();
    }, 220);
  });
});
</script>
